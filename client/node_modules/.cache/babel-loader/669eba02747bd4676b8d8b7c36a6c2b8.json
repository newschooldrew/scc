{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useErrorBoundary = useErrorBoundary;\n\nvar _react = require(\"react\");\n\nvar _createWrappedErrorBoundary = require(\"./utils/create-wrapped-error-boundary\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/**\n * useErrorBoundary\n * React hook to use an ErrorBoundary in your component and keep track of the\n * error state of that boundary.\n *\n * Uses a wrapped class component to create the error Boundary, but uses hooks to keep the state\n * in your function component.\n */\n\n\nfunction useErrorBoundary() {\n  // Reducer handling the error state\n  var _useReducer = (0, _react.useReducer)(function (state, action) {\n    switch (action.type) {\n      // The component did catch, update state\n      case \"catch\":\n        return _objectSpread({}, state, {\n          didCatch: true,\n          // Pass the values from action.error and action.errorInfo\n          error: action.error,\n          errorInfo: action.errorInfo // Unknown action, return state\n\n        });\n\n      default:\n        return state;\n    }\n  }, // Default state\n  {\n    didCatch: false,\n    error: null,\n    errorInfo: null\n  }),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      _useReducer2$ = _useReducer2[0],\n      didCatch = _useReducer2$.didCatch,\n      error = _useReducer2$.error,\n      errorInfo = _useReducer2$.errorInfo,\n      dispatch = _useReducer2[1]; // Create ref for wrapped ErrorBoundary class\n\n\n  var errorBoundaryWrapperRef = (0, _react.useRef)(null); // Get the current ref value or initialize it with a new wrapped ErrorBoundary\n\n  function getWrappedErrorBoundary() {\n    // Get current ref value\n    var errorBoundaryWrapper = errorBoundaryWrapperRef.current; // Return the component when already initialized\n\n    if (errorBoundaryWrapper !== null) {\n      return errorBoundaryWrapper;\n    } // Create new wrapped ErrorBoundary class with onDidCatch callback\n\n\n    errorBoundaryWrapper = (0, _createWrappedErrorBoundary.createWrappedErrorBoundary)({\n      // onDidCatch callback\n      onDidCatch: function onDidCatch(err, errInfo) {\n        // Dispatch action in case of an error\n        dispatch({\n          type: \"catch\",\n          error: err,\n          errorInfo: errInfo\n        });\n      }\n    }); // Update the ref with new component\n\n    errorBoundaryWrapperRef.current = errorBoundaryWrapper; // Return the newly created component\n\n    return errorBoundaryWrapper;\n  } // Return the wrapped ErrorBoundary class to wrap your components in plus the error state\n\n\n  return {\n    ErrorBoundary: getWrappedErrorBoundary(),\n    didCatch: didCatch,\n    error: error,\n    errorInfo: errorInfo\n  };\n}","map":{"version":3,"sources":["/Users/andrewperez/Documents/projects/scc/client/node_modules/use-error-boundary/lib/use-error-boundary.js"],"names":["Object","defineProperty","exports","value","useErrorBoundary","_react","require","_createWrappedErrorBoundary","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","configurable","writable","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","err","Array","isArray","_useReducer","useReducer","state","action","type","didCatch","error","errorInfo","_useReducer2","_useReducer2$","dispatch","errorBoundaryWrapperRef","useRef","getWrappedErrorBoundary","errorBoundaryWrapper","current","createWrappedErrorBoundary","onDidCatch","errInfo","ErrorBoundary"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useErrorBoundary = useErrorBoundary;\n\nvar _react = require(\"react\");\n\nvar _createWrappedErrorBoundary = require(\"./utils/create-wrapped-error-boundary\");\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * useErrorBoundary\n * React hook to use an ErrorBoundary in your component and keep track of the\n * error state of that boundary.\n *\n * Uses a wrapped class component to create the error Boundary, but uses hooks to keep the state\n * in your function component.\n */\nfunction useErrorBoundary() {\n  // Reducer handling the error state\n  var _useReducer = (0, _react.useReducer)(function (state, action) {\n    switch (action.type) {\n      // The component did catch, update state\n      case \"catch\":\n        return _objectSpread({}, state, {\n          didCatch: true,\n          // Pass the values from action.error and action.errorInfo\n          error: action.error,\n          errorInfo: action.errorInfo // Unknown action, return state\n\n        });\n\n      default:\n        return state;\n    }\n  }, // Default state\n  {\n    didCatch: false,\n    error: null,\n    errorInfo: null\n  }),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      _useReducer2$ = _useReducer2[0],\n      didCatch = _useReducer2$.didCatch,\n      error = _useReducer2$.error,\n      errorInfo = _useReducer2$.errorInfo,\n      dispatch = _useReducer2[1]; // Create ref for wrapped ErrorBoundary class\n\n\n  var errorBoundaryWrapperRef = (0, _react.useRef)(null); // Get the current ref value or initialize it with a new wrapped ErrorBoundary\n\n  function getWrappedErrorBoundary() {\n    // Get current ref value\n    var errorBoundaryWrapper = errorBoundaryWrapperRef.current; // Return the component when already initialized\n\n    if (errorBoundaryWrapper !== null) {\n      return errorBoundaryWrapper;\n    } // Create new wrapped ErrorBoundary class with onDidCatch callback\n\n\n    errorBoundaryWrapper = (0, _createWrappedErrorBoundary.createWrappedErrorBoundary)({\n      // onDidCatch callback\n      onDidCatch: function onDidCatch(err, errInfo) {\n        // Dispatch action in case of an error\n        dispatch({\n          type: \"catch\",\n          error: err,\n          errorInfo: errInfo\n        });\n      }\n    }); // Update the ref with new component\n\n    errorBoundaryWrapperRef.current = errorBoundaryWrapper; // Return the newly created component\n\n    return errorBoundaryWrapper;\n  } // Return the wrapped ErrorBoundary class to wrap your components in plus the error state\n\n\n  return {\n    ErrorBoundary: getWrappedErrorBoundary(),\n    didCatch: didCatch,\n    error: error,\n    errorInfo: errorInfo\n  };\n}"]},"metadata":{},"sourceType":"script"}